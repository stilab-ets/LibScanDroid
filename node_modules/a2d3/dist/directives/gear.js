var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Input, Optional, Directive, ElementRef } from '@angular/core';
import { D3ChartDirective, D3Element, D3MarginDirective } from './chart';
import * as d3 from 'd3';
var D3GearDirective = (function (_super) {
    __extends(D3GearDirective, _super);
    function D3GearDirective(chart, el, margin) {
        var _this = _super.call(this, chart, el, margin) || this;
        _this.anglePadding = 0;
        _this.cornerRadiusPercentage = 0;
        _this.radiusScaling = .9;
        _this.innerRadiusScaling = 0.3;
        _this.rotation = 0;
        _this.dx = 0;
        _this.dy = 0;
        _this.element.attr('class', 'gear');
        return _this;
    }
    Object.defineProperty(D3GearDirective.prototype, "colorScale", {
        get: function () {
            return this._colorScale;
        },
        set: function (value) {
            if (d3.scale[value]) {
                this._colorScale = d3.scale[value]();
            }
        },
        enumerable: true,
        configurable: true
    });
    D3GearDirective.prototype.redraw = function () {
        var _this = this;
        var baseRadius = this.height * 0.5 * this.radiusScaling;
        var data = this.data;
        if (this.width > 0 && this.height > 0) {
            this.chart.width = this.width;
            this.chart.height = this.height;
        }
        if (this.chart.width === 0 || this.chart.height === 0) {
            return;
        }
        var xcenter = this.chart.width / 2 + (+this.dx);
        var ycenter = this.chart.height / 2 + (+this.dy);
        var startAngle = 0;
        var endAngle = 2 * Math.PI;
        if (this.format === 'half-left') {
            startAngle = Math.PI;
            xcenter = this.chart.width;
        }
        else if (this.format === 'half-right') {
            endAngle = Math.PI;
            xcenter = 0;
        }
        else {
            var rotationInRadians = this.rotation * Math.PI / 180;
            startAngle = rotationInRadians;
            endAngle = rotationInRadians + 2 * Math.PI;
        }
        this.element.attr('transform', "translate(" + xcenter + ", " + ycenter + ")");
        var pieData = d3.layout.pie()
            .startAngle(startAngle)
            .endAngle(endAngle)
            .padAngle(this.anglePadding)
            .sort(null)
            .value(function (d) { return d[_this.weightField]; })(data);
        var layoutData = [];
        for (var i in data) {
            var d = data[i];
            var pd = pieData[i];
            if (pd.startAngle < 0) {
                pd.startAngle += 2 * Math.PI;
            }
            if (pd.endAngle < 0) {
                pd.endAngle -= 2 * Math.PI;
            }
            var midAngleRadians = ((pd.startAngle + pd.endAngle) / 2) - Math.PI / 2;
            if (midAngleRadians < 0) {
                midAngleRadians += 2 * Math.PI;
            }
            var midAngleDegrees = 180 * midAngleRadians / Math.PI;
            var uy = Math.sin(midAngleRadians);
            var ux = Math.cos(midAngleRadians);
            var halfPi = Math.PI / 2;
            var lr = midAngleRadians > halfPi && midAngleRadians < 3 * halfPi;
            var innerR = this.innerRadiusScaling * baseRadius;
            if (this.innerRadiusField && d[this.innerRadiusField]) {
                innerR = +d[this.innerRadiusField] * baseRadius;
            }
            var outerR = baseRadius;
            if (this.outerRadiusField && d[this.outerRadiusField]) {
                outerR = +d[this.outerRadiusField] * baseRadius;
            }
            var innerLR = (innerR + outerR) / 2;
            if (this.innerLabelRadiusField && d[this.innerLabelRadiusField]) {
                innerLR = +d[this.innerLabelRadiusField] * baseRadius;
            }
            var gapSize = 0.02 * baseRadius;
            var triStart = outerR + gapSize;
            var triEnd = triStart + 0.05 * baseRadius;
            var triSize = triEnd - triStart;
            var outerLR = triEnd + gapSize;
            if (this.outerLabelRadiusField && d[this.outerLabelRadiusField]) {
                outerLR = +d[this.outerLabelRadiusField] * baseRadius;
            }
            var arc = d3.svg.arc()
                .outerRadius(outerR)
                .innerRadius(innerR)
                .cornerRadius(baseRadius * this.cornerRadiusPercentage / 100.0);
            var slicePath = arc(pd);
            var tbx = triStart;
            var tbw = triSize;
            var outerLabelTrianglePath = "M " + tbx + " " + -tbw + " l 0 " + 2 * tbw + " l " + tbw + " " + -tbw + " z";
            layoutData[i] = {
                index: i,
                innerR: innerR,
                innerLabel: d[this.innerLabelField],
                innerLabelX: innerLR * ux,
                innerLabelY: innerLR * uy,
                innerLabelDy: '0.35em',
                innerLabelAnchor: 'middle',
                outerR: outerR,
                outerLabel: d[this.outerLabelField],
                outerLabelX: outerLR * ux,
                outerLabelY: outerLR * uy,
                outerLabelAnchor: lr ? 'end' : 'start',
                outerLabelDy: ((uy + 1) / 2) * .7 + "em",
                midDegrees: midAngleDegrees,
                pd: pd,
                arc: arc,
                slicePath: slicePath,
                outerLabelTrianglePath: outerLabelTrianglePath,
            };
        }
        var slices = this.element.selectAll('path.gear').data(layoutData);
        slices
            .enter()
            .append('path')
            .attr('class', function (d, i) { return "gear gear-" + i; })
            .attr('d', function (d, i) { return d.slicePath; })
            .attr('fill', function (d, i) { return _this.getColors(d, i); });
        slices.exit().remove();
        var triangles = this.element.selectAll('path.gear-label-triangle').data(layoutData);
        triangles
            .enter()
            .append('path')
            .attr('class', function (d, i) { return "gear-label-triangle gear-label-triangle-" + i; })
            .attr('transform', function (d) { return "rotate(" + d.midDegrees + ")"; })
            .attr('d', function (d) { return d.outerLabelTrianglePath; })
            .attr('fill', this.triangleColor || 'grey');
        var innerLabel = this.element.selectAll('text.gear-label-inner').data(layoutData);
        innerLabel.enter()
            .append('text')
            .attr('class', function (d, i) { return "gear-label-inner gear-label-inner-" + i; })
            .attr('text-anchor', function (d) { return d.innerLabelAnchor; })
            .attr('dy', function (d) { return d.innerLabelDy; })
            .attr('transform', function (d) { return "translate(" + d.innerLabelX + ", " + d.innerLabelY + ")"; })
            .text(function (d) { return d.innerLabel; });
        innerLabel.exit().remove();
        var outerLabel = this.element.selectAll('text.gear-label-outer').data(layoutData);
        outerLabel.enter()
            .append('text')
            .attr('class', function (d, i) { return "gear-label-outer gear-label-outer-" + i; })
            .attr('text-anchor', function (d) { return d.outerLabelAnchor; })
            .attr('class', function (d, i) { return "gear-label-outer gear-label-outer-" + i; })
            .attr('dy', function (d) { return d.outerLabelDy; })
            .attr('transform', function (d) { return "translate(" + d.outerLabelX + ", " + d.outerLabelY + ")"; })
            .text(function (d) { return d.outerLabel; });
        outerLabel.exit().remove();
        this.layout = layoutData;
    };
    D3GearDirective.prototype.getColors = function (d, i) {
        if (this.colorScale) {
            return this.colorScale(i);
        }
        if (this.color) {
            return d[this.color];
        }
        if (d.color) {
            return d.color;
        }
    };
    return D3GearDirective;
}(D3Element));
export { D3GearDirective };
D3GearDirective.decorators = [
    { type: Directive, args: [{
                selector: '[d3-gear]'
            },] },
];
D3GearDirective.ctorParameters = function () { return [
    { type: D3ChartDirective, },
    { type: ElementRef, },
    { type: D3MarginDirective, decorators: [{ type: Optional },] },
]; };
D3GearDirective.propDecorators = {
    'duration': [{ type: Input },],
    'transition': [{ type: Input },],
    'weightField': [{ type: Input, args: ['weight-field',] },],
    'color': [{ type: Input },],
    'innerLabelField': [{ type: Input, args: ['inner-label-field',] },],
    'innerRadiusField': [{ type: Input, args: ['inner-radius-field',] },],
    'innerLabelRadiusField': [{ type: Input, args: ['inner-label-radius-field',] },],
    'outerLabelField': [{ type: Input, args: ['outer-label-field',] },],
    'outerRadiusField': [{ type: Input, args: ['outer-radius-field',] },],
    'outerLabelRadiusField': [{ type: Input, args: ['outer-label-radius-field',] },],
    'anglePadding': [{ type: Input, args: ['angle-padding',] },],
    'cornerRadiusPercentage': [{ type: Input, args: ['corner-radius-percentage',] },],
    'triangleColor': [{ type: Input, args: ['triangle-color',] },],
    'format': [{ type: Input },],
    'radiusScaling': [{ type: Input, args: ['radius-scaling',] },],
    'innerRadiusScaling': [{ type: Input, args: ['inner-radius-scaling',] },],
    'rotation': [{ type: Input },],
    'dx': [{ type: Input },],
    'dy': [{ type: Input },],
    'colorScale': [{ type: Input, args: ['color-scale',] },],
};
//# sourceMappingURL=gear.js.map