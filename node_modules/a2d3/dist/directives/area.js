var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Input, Optional, Directive, ElementRef } from '@angular/core';
import { D3ChartDirective, D3Element, D3MarginDirective } from './chart';
import * as d3 from 'd3';
var D3AreaDirective = (function (_super) {
    __extends(D3AreaDirective, _super);
    function D3AreaDirective(chart, el, margin) {
        var _this = _super.call(this, chart, el, margin) || this;
        _this._areaElement = _this.element.attr('class', 'area');
        return _this;
    }
    Object.defineProperty(D3AreaDirective.prototype, "columns", {
        get: function () {
            if (this._columns) {
                return this._columns;
            }
            else {
                return [this.yDataName];
            }
        },
        set: function (value) {
            if (value instanceof String) {
                value = value.split(',').map(function (v) { return v.trim(); });
            }
            if (Array.isArray(value)) {
                this._columns = value;
                this.redraw();
            }
        },
        enumerable: true,
        configurable: true
    });
    D3AreaDirective.prototype.redraw = function () {
        var data = this.data;
        var stack = d3.layout.stack();
        if (this.offset) {
            stack.offset(this.offset);
        }
        stack.values(function (d) { return d.values; });
        var stackedData = stack(this.mapColumns(data));
        var area = this.getArea();
        var nullArea = this.getNullArea();
        var elements = this._areaElement.selectAll('path.area').data(stackedData);
        elements.enter()
            .append('path').attr('class', function (d) { return "area area-" + d.name; })
            .attr('d', nullArea);
        elements.transition().duration(500)
            .attr('class', function (d) { return "area area-" + d.name; })
            .attr('d', area);
        elements.exit()
            .transition().duration(500)
            .attr('d', nullArea)
            .remove();
    };
    D3AreaDirective.prototype.getNullArea = function () {
        var _this = this;
        var area = d3.svg.area()
            .x(function (d, i) { return _this.x(d.x); })
            .y0(function () { return _this.height; })
            .y1(function () { return _this.height; });
        var areaStacked = d3.svg.area()
            .x(function (d) { return _this.x(d.x); })
            .y0(function (d) { return _this.y(d.y0); })
            .y1(function (d) { return _this.y(d.y0); });
        return function (d, i) {
            if (i === 0) {
                return area(d.values);
            }
            else {
                return areaStacked(d.values);
            }
        };
    };
    D3AreaDirective.prototype.getArea = function () {
        var _this = this;
        var area;
        var areaStacked;
        if (this.vertical) {
            area = d3.svg.area()
                .y(function (d) { return _this.x(d.x); })
                .x0(0)
                .x1(function (d) { return _this.y(d.y); });
            areaStacked = d3.svg.area()
                .y(function (d) { return _this.x(d.x); })
                .x0(function (d) { return _this.y(d.y0); })
                .x1(function (d) { return _this.y(d.y + d.y0); });
        }
        else {
            area = d3.svg.area()
                .x(function (d) { return _this.x(d.x); })
                .y0(function () { return _this.height; })
                .y1(function (d) { return _this.y(d.y); });
            areaStacked = d3.svg.area()
                .x(function (d) { return _this.x(d.x); })
                .y0(function (d) { return _this.y(d.y0); })
                .y1(function (d) { return _this.y(d.y + d.y0); });
        }
        return function (d, i) {
            if (i === 0) {
                return area(d.values);
            }
            else {
                return areaStacked(d.values);
            }
        };
    };
    D3AreaDirective.prototype.mapColumns = function (data) {
        var _this = this;
        return this.columns.map(function (c) { return ({
            name: c,
            values: _this.mapValues(data, c)
        }); });
    };
    D3AreaDirective.prototype.mapValues = function (data, c) {
        var _this = this;
        return data.map(function (d) { return ({
            x: d[_this.xDataName],
            y: d[c]
        }); });
    };
    Object.defineProperty(D3AreaDirective.prototype, "x", {
        get: function () {
            return (this._xScale = this._xScale
                || this.getScale(this.xScaleName || this.xDataName)).scale;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(D3AreaDirective.prototype, "y", {
        get: function () {
            return (this._yScale = this._yScale
                || this.getScale(this.yScaleName || this.yDataName)).scale;
        },
        enumerable: true,
        configurable: true
    });
    return D3AreaDirective;
}(D3Element));
export { D3AreaDirective };
D3AreaDirective.decorators = [
    { type: Directive, args: [{
                selector: '[d3-area]'
            },] },
];
D3AreaDirective.ctorParameters = function () { return [
    { type: D3ChartDirective, },
    { type: ElementRef, },
    { type: D3MarginDirective, decorators: [{ type: Optional },] },
]; };
D3AreaDirective.propDecorators = {
    'name': [{ type: Input },],
    'vertical': [{ type: Input },],
    'xDataName': [{ type: Input, args: ['x',] },],
    'yDataName': [{ type: Input, args: ['y',] },],
    'yScaleName': [{ type: Input, args: ['yscale',] },],
    'xScaleName': [{ type: Input, args: ['xscale',] },],
    'offset': [{ type: Input },],
    'stroke': [{ type: Input },],
    'columns': [{ type: Input },],
};
//# sourceMappingURL=area.js.map