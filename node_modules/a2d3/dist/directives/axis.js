var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Input, Directive, ElementRef, Optional } from '@angular/core';
import { D3ChartDirective, D3MarginDirective, D3Element } from './chart';
import * as d3 from 'd3';
import * as cloneDeep from 'lodash/fp/cloneDeep';
var D3AxisDirective = (function (_super) {
    __extends(D3AxisDirective, _super);
    function D3AxisDirective(chart, el, margin) {
        var _this = _super.call(this, chart, el, margin) || this;
        _this.orientation = 'bottom';
        _this.reverse = false;
        _this.extent = false;
        _this.ticks = 5;
        _this._scale = d3.scale.linear();
        chart.addScale(_this);
        return _this;
    }
    D3AxisDirective.prototype.redraw = function () {
        var _this = this;
        var data = this.data;
        if (!data || !data.length) {
            return;
        }
        this.updateAxis();
        this.updateLabel();
        this.updateGrid();
        if (!data || data.length < 0) {
            return;
        }
        var scale = this._scale;
        scale.range(this.range);
        var domain = this.filter ? this.filter(data) : data.map(function (d) { return d[_this.name]; });
        if (this.extent) {
            scale.domain(d3.extent(domain));
        }
        else {
            scale.domain([0, d3.max(domain)]);
        }
    };
    Object.defineProperty(D3AxisDirective.prototype, "scale", {
        get: function () {
            return this._scale;
        },
        set: function (value) {
            if (value === 'time') {
                this._scale = d3.time.scale();
            }
            else if (value) {
                this._scale = d3.scale[value]();
            }
            else {
                this._scale = d3.scale.linear();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(D3AxisDirective.prototype, "grid", {
        get: function () {
            return this._grid;
        },
        set: function (value) {
            this._grid = (value === 'true' || value === true);
            this.updateGrid();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(D3AxisDirective.prototype, "label", {
        get: function () {
            return this._label;
        },
        set: function (value) {
            this._label = value;
            if (this._labelElement) {
                this._labelElement.text(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    D3AxisDirective.prototype.isVertical = function () {
        return this.orientation === 'top' || this.orientation === 'bottom';
    };
    Object.defineProperty(D3AxisDirective.prototype, "range", {
        get: function () {
            var range;
            if (this.orientation === 'top' || this.orientation === 'bottom') {
                range = [0, this.width];
            }
            else {
                range = [this.height, 0];
            }
            if (this.reverse) {
                range = range.reverse();
            }
            return range;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(D3AxisDirective.prototype, "translation", {
        get: function () {
            return {
                'bottom': "translate(0, " + this.height + ")",
                'right': "translate(" + this.width + ", 0)"
            }[this.orientation] || 'translate(0, 0)';
        },
        enumerable: true,
        configurable: true
    });
    D3AxisDirective.prototype.createAxis = function () {
        var axis = d3.svg.axis().scale(this.scale).orient(this.orientation);
        if (this.ticks) {
            axis.ticks(this.ticks);
        }
        if (this.timeScale) {
            axis.ticks(d3.time[this.timeScale], this.timeInterval);
        }
        if (this.tickValues) {
            axis.tickValues(this.tickValues);
        }
        if (this.tickSize) {
            var tickSize = this.tickSize.split(',');
            axis.innerTickSize(+tickSize[0]);
            axis.outerTickSize(+tickSize[1]);
        }
        if (this.customTimeFormat) {
            var copy = cloneDeep(this.customTimeFormat);
            var mf_1 = d3.time.format.multi(copy);
            axis.tickFormat(function (d) { return mf_1(new Date(d)); });
        }
        if (this.timeFormat) {
            var tf_1 = d3.time.format(this.timeFormat);
            axis.tickFormat(function (d) { return tf_1(new Date(d)); });
        }
        else if (this.format) {
            axis.tickFormat(d3.format(this.format));
        }
        return axis;
    };
    D3AxisDirective.prototype.adjustTickLabels = function (axis) {
        var tickLabels = axis.selectAll('.tick text');
        if (this.tickDy) {
            tickLabels.attr('dy', this.tickDy);
        }
        if (this.tickDx) {
            tickLabels.attr('dx', this.tickDx);
        }
        if (this.tickAnchor) {
            tickLabels.style('text-anchor', this.tickAnchor);
        }
        var lastTickLabels = d3.select(tickLabels[0].slice(-1)[0]);
        if (this.lastTickDy) {
            lastTickLabels.attr('dy', this.lastTickDy);
        }
        if (this.lastTickDx) {
            lastTickLabels.attr('dx', this.lastTickDx);
        }
        if (this.lastTickAnchor) {
            lastTickLabels.style('text-anchor', this.lastTickAnchor);
        }
        var firstTickLabels = d3.select(tickLabels[0][0]);
        if (this.firstTickDy) {
            firstTickLabels.attr('dy', this.firstTickDy);
        }
        if (this.firstTickDx) {
            firstTickLabels.attr('dx', this.firstTickDx);
        }
        if (this.firstTickAnchor) {
            firstTickLabels.style('text-anchor', this.firstTickAnchor);
        }
    };
    D3AxisDirective.prototype.updateAxis = function () {
        if (!this._axisElement) {
            this._axisElement = this.element.append('g');
        }
        var axis = this._axisElement;
        axis.attr('class', "axis axis-" + this.orientation + " axis-" + this.name)
            .attr('transform', this.translation)
            .call(this.createAxis());
        this.adjustTickLabels(axis);
    };
    D3AxisDirective.prototype.updateLabel = function () {
        if (!this._axisElement) {
            return;
        }
        if (!this._labelElement) {
            this._labelElement = this._axisElement
                .append('text')
                .attr('class', 'axis-label');
        }
        this._labelElement.text(this._label);
        this.positionLabel(this._labelElement);
    };
    D3AxisDirective.prototype.positionLabel = function (label) {
        switch (this.orientation) {
            case 'bottom':
                label.attr('x', "" + this.width / 2)
                    .attr('dy', "" + this.margin.bottom)
                    .attr('style', 'text-anchor: middle;');
                break;
            case 'top':
                label.attr('x', "" + this.width / 2)
                    .attr('dy', "" + -this.margin.top)
                    .attr('style', 'text-anchor: middle;');
                break;
            case 'left':
                label.attr('x', "" + (this.height / 2) * -1)
                    .attr('dy', "" + (-this.margin.left + 18))
                    .attr('style', 'text-anchor: middle;')
                    .attr('transform', 'rotate(-90)');
                break;
            case 'right':
                label.attr('x', "" + this.height / 2)
                    .attr('dy', "" + (-this.margin.right + 18))
                    .attr('style', 'text-anchor: middle;')
                    .attr('transform', 'rotate(90)');
                break;
        }
    };
    D3AxisDirective.prototype.updateGrid = function () {
        if (this._grid && this._axisElement) {
            this._gridElement = this._gridElement || this.element.append('g')
                .attr('class', "axis-grid axis-grid-" + this.name);
            this.drawGrid();
        }
        else if (this._gridElement) {
            this._gridElement.remove();
            this._gridElement = null;
        }
    };
    D3AxisDirective.prototype.drawGrid = function () {
        var size;
        var transform;
        switch (this.orientation) {
            case 'bottom':
                size = this.height;
                break;
            case 'top':
                transform = "translate(0, " + this.height + ")";
                size = this.height;
                break;
            case 'left':
                transform = "translate(" + this.width + ", 0)";
                size = this.width;
                break;
            case 'right':
                size = this.width;
                break;
        }
        if (transform) {
            this._gridElement.attr('transform', transform);
        }
        var axis = this.createAxis().innerTickSize(size).outerTickSize(0).tickFormat('');
        this._gridElement.call(axis);
    };
    return D3AxisDirective;
}(D3Element));
export { D3AxisDirective };
D3AxisDirective.decorators = [
    { type: Directive, args: [{
                selector: '[d3-axis]'
            },] },
];
D3AxisDirective.ctorParameters = function () { return [
    { type: D3ChartDirective, },
    { type: ElementRef, },
    { type: D3MarginDirective, decorators: [{ type: Optional },] },
]; };
D3AxisDirective.propDecorators = {
    'name': [{ type: Input },],
    'format': [{ type: Input },],
    'timeFormat': [{ type: Input, args: ['time-format',] },],
    'timeScale': [{ type: Input, args: ['time-scale',] },],
    'timeInterval': [{ type: Input, args: ['time-interval',] },],
    'tickSize': [{ type: Input, args: ['tick-size',] },],
    'tickDx': [{ type: Input, args: ['tick-dx',] },],
    'tickDy': [{ type: Input, args: ['tick-dy',] },],
    'tickAnchor': [{ type: Input, args: ['tick-anchor',] },],
    'firstTickDx': [{ type: Input, args: ['first-tick-dx',] },],
    'firstTickDy': [{ type: Input, args: ['first-tick-dy',] },],
    'firstTickAnchor': [{ type: Input, args: ['first-tick-anchor',] },],
    'lastTickDx': [{ type: Input, args: ['last-tick-dx',] },],
    'lastTickDy': [{ type: Input, args: ['last-tick-dy',] },],
    'lastTickAnchor': [{ type: Input, args: ['last-tick-anchor',] },],
    'customTimeFormat': [{ type: Input, args: ['custom-time-format',] },],
    'tickValues': [{ type: Input, args: ['tick-values',] },],
    'filter': [{ type: Input },],
    'orientation': [{ type: Input },],
    'reverse': [{ type: Input },],
    'extent': [{ type: Input },],
    'ticks': [{ type: Input },],
    'scale': [{ type: Input },],
    'grid': [{ type: Input },],
    'label': [{ type: Input },],
};
//# sourceMappingURL=axis.js.map